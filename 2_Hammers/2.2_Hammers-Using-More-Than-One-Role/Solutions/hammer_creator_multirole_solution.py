########################################################################
#...Prompt that generated this program:
"""
Please write a python program named 'hammer_creator_advanced.py' that will:

* Accept as '-K' a mandatory integer Kmer-length command-line argument;
        
* Read a FASTA-formatted file from 'STDIN' using BioPython,
and foreach FASTA entry extract the following:

  - The portion of the FASTA header up to the first whitespace-character is the
  "feature-ID" ('fid') for the FASTA entry;
  the remainder of the FASTA header starting with the first non-whitespace character
  after the whitespace is that feature's "role".
  There may be more than one whitespace-character separating the feature-ID
  from its role.
  Please extract the feature-ID and the role frome the FASTA header,
  then convert the sequence to lower-case,
  and build dictionaries mapping feature-IDs to sequences,
  and feature-IDs to their roles.

  - Each feature-ID has the format 'fig|x.y.peg.z', where 'x', 'y', and 'z' are integers,
  and the 'fig|' and '.peg' portions are literal strings, not variables.
  The substring 'x.y' is the 'genome_id' for the feature;
  please use a regular expression to extract the genome-ID from the feature-ID,
  and build a dictionary mapping feature-IDs to genome-IDs. 

  - Return the dictionary mapping feature-IDs to genomes,
  the dictionary mapping feature-IDs to roles,
  and the dictionary mapping feature-IDs to sequences.

* Print a tab-separated header-line to STDOUT, whose column-names are
  "hammer", "fid", and "role".

* Create an empty "dictionary of dictionaries" whose outer-keys will be Kmers,
  inner-keys will be feature-IDs, and inner-values will be integer counts.

* Foreach sequence, find all of its Kmers, and foreach Kmer
  increment the count for that sequence's feature-ID
  in the dictionary-of-dictionaries.

* A "hammer" is defined as a Kmer that occur exactly once in exactly one genome-ID.
  Each feature-ID can only occur in one genome.
  So if a Kmer occurs with a count of '1' in exactly one feature, 
  then it must be a "hammer".
  Find all of the "hammers" in the dictionary-of-dictionaries,
  and print to STDOUT a three-column table table of "hammer", "feature-ID",
  and "role" for that feature-ID, sorted by hammer.

* Finally, please print to 'STDERR' the number of sequences that were read,
  the number of Kmers that were processed, and the number of Kmers that were hammers,
  then exit.
"""

########################################################################
#...Pseudocode for this program:
"""
def main():
    # Parse command-line arguments
    if incorrect number of arguments or '-K' flag is missing:
        print usage message to STDERR
        exit program

    try:
        parse kmer_length as an integer from command-line arguments
    except ValueError:
        print error message to STDERR
        exit program

    # Initialize data structures
    initialize dictionaries:
        feature_to_sequence
        feature_to_role
        feature_to_genome
    initialize a defaultdict of defaultdicts for kmer_dict
    initialize counters:
        sequence_count
        kmer_count

    # Process FASTA input from STDIN
    for each record in FASTA input:
        increment sequence_count

        extract header from record
        if header matches feature-ID and role pattern:
            extract feature-ID and role
        else:
            print error message to STDERR
            continue to next record

        if feature-ID matches genome-ID pattern:
            extract genome-ID
        else:
            print error message to STDERR
            continue to next record

        store sequence in feature_to_sequence (convert to lowercase)
        store role in feature_to_role
        store genome-ID in feature_to_genome

    # Build kmer dictionary
    for each feature_ID and sequence in feature_to_sequence:
        for each kmer in the sequence:
            add kmer to kmer_dict with feature_ID as key and increment count
            increment kmer_count

    # Find and output hammers
    print header line to STDOUT ("hammer\tfid\trole")
    initialize hammer_count to 0

    for each kmer and feature_counts in sorted kmer_dict:
        if kmer appears in exactly one feature_ID with a count of 1:
            increment hammer_count
            retrieve role for feature_ID
            print kmer, feature_ID, and role to STDOUT

    # Print summary statistics to STDERR
    print number of sequences read to STDERR
    print number of kmers processed to STDERR
    print number of hammers found to STDERR

if script is run as main program:
    call main()
"""

########################################################################
#...Code generated by Grimoire:
import sys
import re
from Bio import SeqIO
from collections import defaultdict

def main():
    # Parse command-line arguments
    if len(sys.argv) != 3 or sys.argv[1] != '-K':
        print("Usage: python hammer_creator_advanced.py -K <Kmer-length>", file=sys.stderr)
        sys.exit(1)

    try:
        kmer_length = int(sys.argv[2])
    except ValueError:
        print("Error: Kmer-length must be an integer.", file=sys.stderr)
        sys.exit(1)

    # Initialize data structures
    feature_to_sequence = {}
    feature_to_role = {}
    feature_to_genome = {}
    kmer_dict = defaultdict(lambda: defaultdict(int))

    sequence_count = 0
    kmer_count = 0

    # Process FASTA from STDIN
    for record in SeqIO.parse(sys.stdin, "fasta"):
        sequence_count += 1

        # Extract feature-ID and role
        header = record.description
        match = re.match(r"(\S+)\s+(.*)", header)
        if not match:
            print(f"Error: Unable to parse FASTA header: {header}", file=sys.stderr)
            continue

        feature_id = match.group(1)
        role = match.group(2).strip()

        # Extract genome-ID from feature-ID
        genome_match = re.match(r"fig\|(\d+\.\d+)\.peg\.\d+", feature_id)
        if not genome_match:
            print(f"Error: Invalid feature-ID format: {feature_id}", file=sys.stderr)
            continue

        genome_id = genome_match.group(1)
        
        # Store mappings
        feature_to_sequence[feature_id] = str(record.seq).lower()
        feature_to_role[feature_id] = role
        feature_to_genome[feature_id] = genome_id

    # Build the dictionary of dictionaries for Kmers
    for feature_id, sequence in feature_to_sequence.items():
        for i in range(len(sequence) - kmer_length + 1):
            kmer = sequence[i:i + kmer_length]
            kmer_dict[kmer][feature_id] += 1
            kmer_count += 1

    # Find and output hammers
    print("hammer\tfid\trole")
    hammer_count = 0
    
    for kmer, feature_counts in sorted(kmer_dict.items()):
        if len(feature_counts) == 1:
            feature_id, count = next(iter(feature_counts.items()))
            if count == 1:
                hammer_count += 1
                role = feature_to_role[feature_id]
                print(f"{kmer}\t{feature_id}\t{role}")

    # Print summary statistics to STDERR
    print(f"Sequences read: {sequence_count}", file=sys.stderr)
    print(f"Kmers processed: {kmer_count}", file=sys.stderr)
    print(f"Hammers found: {hammer_count}", file=sys.stderr)

if __name__ == "__main__":
    main()
