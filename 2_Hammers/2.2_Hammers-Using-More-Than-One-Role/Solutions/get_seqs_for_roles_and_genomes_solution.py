########################################################################
#...Prompt that generated this program:
"""
Please write a python program named 'get_seqs_for_roles_and_genomes.py'
that accepts 3 mandatory named arguments.
The output from the '--help' argument should clearly indicate
that the program writes FASTA sequence-data to STDOUT.

* The three mandatory named arguments are:
  - A Type-flag, short name '-T', long name '--type',
    with allowed values of 'dna' or 'protein'.
    
  - The filename of a tab-separated-value list containing genome-IDs,
    short name '-G', long name '--genome-list'.

  - The filename of a tab-separated-value list of roles,
    short name '-R', long-name '--role-list'.

* The program should read the header-line of the role-name file,
and load the values in its 'role_name' column into a list.

* Foreach role in the role-list, print a progress-message to STDERR,
and then execute the following two commands, piping the output of 'cmd1'
to the input of 'cmd2', trapping any errors thrown by either command,
and printing the output of 'cmd2' to STDOUT;
note that the role can contain whitespace, and so this argument must be quoted:

   cmd1 = f"p3-get-genome-features --selective --input {genomes_filename} --col genome_id --eq product,'{role}' --attr patric_id"

   cmd2 = f"p3-get-feature-sequence --col feature.patric_id --{type}"

If either command fails, print the trapped error-message to STDERR, and then exit.
"""

########################################################################
#...Pseudocode for this program:
"""
DEFINE FUNCTION main:
    INITIALIZE parser AS ArgumentParser WITH description "Extract sequences based on roles and genomes. Writes FASTA sequence-data to STDOUT."

    ADD ARGUMENT '-T' OR '--type' TO parser WITH choices ['dna', 'protein'], required=True, and help="Type of sequences to retrieve: 'dna' or 'protein'"
    ADD ARGUMENT '-G' OR '--genome-list' TO parser WITH required=True and help="Filename of the tab-separated-value list containing genome-IDs"
    ADD ARGUMENT '-R' OR '--role-list' TO parser WITH required=True and help="Filename of the tab-separated-value list containing roles"

    PARSE args FROM parser

    SET genomes_filename TO args.genome_list
    SET roles_filename TO args.role_list
    SET seq_type TO args.type

    TRY:
        OPEN roles_filename AS roles_file
            INITIALIZE reader AS CSV DictReader WITH delimiter '\t'
            IF 'role_name' NOT IN reader.fieldnames:
                RAISE ValueError "The 'role_name' column is missing in the role-list file."
            INITIALIZE roles AS LIST OF role_name VALUES FROM reader

        FOR EACH role IN roles:
            PRINT "Processing role: {role}" TO STDERR

            SET cmd1 TO "p3-get-genome-features --selective --input {genomes_filename} --col genome_id --eq product,'{role}' --attr patric_id"
            SET cmd2 TO "p3-get-feature-sequence --col feature.patric_id --{seq_type}"

            TRY:
                INITIALIZE process1 AS subprocess.Popen WITH cmd1, shell=True, stdout=PIPE, stderr=PIPE
                INITIALIZE process2 AS subprocess.Popen WITH cmd2, shell=True, stdin=process1.stdout, stdout=PIPE, stderr=PIPE
                CLOSE process1.stdout

                SET output, error TO process2.communicate()

                IF process1.returncode IS NOT None AND process1.returncode != 0:
                    RAISE subprocess.CalledProcessError WITH process1.returncode, cmd1, and output=process1.stderr.read()

                IF process2.returncode IS NOT None AND process2.returncode != 0:
                    RAISE subprocess.CalledProcessError WITH process2.returncode, cmd2, and output=error

                WRITE output TO STDOUT

            EXCEPT subprocess.CalledProcessError AS e:
                PRINT "Error executing command: {e.cmd}\n{e.output.decode('utf-8')}" TO STDERR
                EXIT 1

    EXCEPT Exception AS e:
        PRINT "An error occurred: {e}" TO STDERR
        EXIT 1

CALL main
"""

########################################################################
#...Code generated by Grimoire:
import argparse
import subprocess
import sys
import csv


def main():
    parser = argparse.ArgumentParser(description="Extract sequences based on roles and genomes. Writes FASTA sequence-data to STDOUT.")

    parser.add_argument(
        '-T', '--type',
        choices=['dna', 'protein'],
        required=True,
        help="Type of sequences to retrieve: 'dna' or 'protein'"
    )

    parser.add_argument(
        '-G', '--genome-list',
        required=True,
        help="Filename of the tab-separated-value list containing genome-IDs"
    )

    parser.add_argument(
        '-R', '--role-list',
        required=True,
        help="Filename of the tab-separated-value list containing roles"
    )

    args = parser.parse_args()

    genomes_filename = args.genome_list
    roles_filename = args.role_list
    seq_type = args.type

    try:
        # Load roles from the role-list file
        with open(roles_filename, 'r') as roles_file:
            reader = csv.DictReader(roles_file, delimiter='\t')
            if 'role_name' not in reader.fieldnames:
                raise ValueError("The 'role_name' column is missing in the role-list file.")
            roles = [row['role_name'] for row in reader]

        for role in roles:
            print(f"Processing role: {role}", file=sys.stderr)

            cmd1 = (
                f"p3-get-genome-features --selective --input {genomes_filename} --col genome_id "
                f"--eq product,'{role}' --attr patric_id"
            )

            cmd2 = f"p3-get-feature-sequence --col feature.patric_id --{seq_type}"

            try:
                # Execute the commands
                process1 = subprocess.Popen(cmd1, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                process2 = subprocess.Popen(cmd2, shell=True, stdin=process1.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                process1.stdout.close()  # Allow process1 to receive a SIGPIPE if process2 exits

                output, error = process2.communicate()

                if process1.returncode not in (None, 0):
                    raise subprocess.CalledProcessError(process1.returncode, cmd1, output=process1.stderr.read())

                if process2.returncode not in (None, 0):
                    raise subprocess.CalledProcessError(process2.returncode, cmd2, output=error)

                # Print the output of cmd2 to STDOUT
                sys.stdout.write(output.decode('utf-8'))

            except subprocess.CalledProcessError as e:
                print(f"Error executing command: {e.cmd}\n{e.output.decode('utf-8')}", file=sys.stderr)
                sys.exit(1)

    except Exception as e:
        print(f"An error occurred: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
