########################################################################
#...Prompt that generated this program:
"""
Please write a python program named 'filter_hammer_candidates.py' that:

* Accepts a mandatory directory-name argument for a directory
containing a set of FASTA contig files, short name '-D',
long name '--contigs-directory'.

* Reads a hammer-candidate file as a tab-seperated-value file from STDIN,
saves the header-line, and loads the remainder of the file into
a dictionary called the "hammer dictionary",
with the first field as the key, and the entire line as the value.
The keys are named "hammer candidates"; note that all hammers have the same length.
The hammer read-function should return the number of candidates read,
the hammer-length, the header-line, and the hammer-dictionary.

* Reads the contents of the contigs directory.

* Foreach file in the contigs directory,
print the progress-message f"Processing '{filename}'" to STDERR,
where 'filename' is the name of the file, 
and then use BioPython to read the file as a set of 
FASTA-formatted DNA contigs.

* Foreach contig, convert the contig-sequence to lower-case,
and find all Kmers with length equal to the hammer-length
on both the forward and reverse-complement sequences.

* For each Kmer extracted from the contig and its reverse-complement:
  - Check the hammer-dictionary to see if that Kmer is a hammer candidate,
  
  - If the Kmer is a hammer candidate, increment the count for that Kmer
    in the candidate-count dictionary.
    
  - If the count for a condidate exceeds '1', delete that candidate's entry
    from the hammer dictionary, and increment a count of the number
    of candidates eliminated.

* Print the saved header-line to STDOUT, sort the remaining keys
in the hammer-dictionary (now called "Accepted hammers"),
and then foreach accepted candidate in the hammer-dictionary,
print its value to STDOUT.

* Finally, print a blank line to STDERR,
then the number of candidates read,
the number of candidates eliminated,
and the number of hammers accepted, then exit.
"""

########################################################################
#...Pseudocode for this program:
"""
FUNCTION read_hammer_candidates(stdin):
    INITIALIZE hammer_dict AS empty dictionary
    SET header_line TO READ first line from stdin and remove whitespace
    SET hammer_length TO None

    FOR EACH line IN stdin:
        SPLIT line BY tab delimiter INTO fields
        SET key TO first element in fields
        IF hammer_length IS None:
            SET hammer_length TO LENGTH of key
        ADD key and line (without whitespace) TO hammer_dict

    RETURN LENGTH of hammer_dict, hammer_length, header_line, hammer_dict

FUNCTION process_contigs(contigs_directory, hammer_length, hammer_dict):
    INITIALIZE candidate_count AS a dictionary with default integer values
    SET eliminated_count TO 0

    FOR EACH filename IN contigs_directory:
        SET file_path TO JOIN contigs_directory and filename

        IF file_path IS NOT a regular file:
            CONTINUE LOOP
        ELSE:
            OUTPUT "Processing file '<filename>'" TO STDERR

        FOR EACH record IN file PARSED as FASTA format:
            SET seq TO lowercased sequence from record
            SET rev_comp TO reverse complement of seq (lowercased)

            INITIALIZE kmers AS SET OF substrings (length hammer_length) FROM seq
            ADD substrings (length hammer_length) FROM rev_comp TO kmers

            FOR EACH kmer IN kmers:
                IF kmer EXISTS IN hammer_dict:
                    INCREMENT candidate_count[kmer] BY 1
                    IF candidate_count[kmer] > 1:
                        DELETE kmer FROM hammer_dict
                        INCREMENT eliminated_count BY 1

    RETURN eliminated_count

FUNCTION main():
    PARSE COMMAND-LINE ARGUMENTS TO GET contigs_directory

    CALL read_hammer_candidates(sys.stdin) RETURNING candidates_read, hammer_length, header_line, hammer_dict

    CALL process_contigs(contigs_directory, hammer_length, hammer_dict) RETURNING eliminated_count

    PRINT header_line TO STDOUT
    FOR EACH key IN hammer_dict SORTED BY keys:
        PRINT hammer_dict[key] TO STDOUT

    CALCULATE accepted_count AS LENGTH of hammer_dict
    PRINT statistics (candidates_read, eliminated_count, accepted_count) TO STDERR

IF script IS executed as MAIN:
    CALL main()
"""

########################################################################
#...Code generated by Grimoire:
import os
import sys
import argparse
from collections import defaultdict
from Bio import SeqIO
from Bio.Seq import Seq


def read_hammer_candidates(stdin):
    """Reads the hammer candidate file from STDIN."""
    hammer_dict = {}
    header_line = stdin.readline().strip()
    hammer_length = None

    for line in stdin:
        fields = line.strip().split("\t")
        key = fields[0]
        if hammer_length is None:
            hammer_length = len(key)
        hammer_dict[key] = line.strip()

    return len(hammer_dict), hammer_length, header_line, hammer_dict


def process_contigs(contigs_directory, hammer_length, hammer_dict):
    """Processes the contig files and identifies hammer candidates."""
    candidate_count = defaultdict(int)
    eliminated_count = 0

    for filename in os.listdir(contigs_directory):
        file_path = os.path.join(contigs_directory, filename)

        if not os.path.isfile(file_path):
            continue
        else:
            print(f"Processing file '{filename}'", file=sys.stderr)
        
        for record in SeqIO.parse(file_path, "fasta"):
            seq = str(record.seq).lower()
            rev_comp = str(Seq(seq).reverse_complement()).lower()

            # Generate Kmers for forward and reverse complement
            kmers = set(seq[i:i + hammer_length] for i in range(len(seq) - hammer_length + 1))
            kmers.update(rev_comp[i:i + hammer_length] for i in range(len(rev_comp) - hammer_length + 1))

            for kmer in kmers:
                if kmer in hammer_dict:
                    candidate_count[kmer] += 1
                    if candidate_count[kmer] > 1:
                        del hammer_dict[kmer]
                        eliminated_count += 1

    return eliminated_count


def main():
    parser = argparse.ArgumentParser(description="Filter hammer candidates.")
    parser.add_argument("-D", "--contigs-directory", required=True, help="Directory containing FASTA contig files.")
    args = parser.parse_args()

    # Read hammer candidates from STDIN
    candidates_read, hammer_length, header_line, hammer_dict = read_hammer_candidates(sys.stdin)

    # Process the contigs directory
    eliminated_count = process_contigs(args.contigs_directory, hammer_length, hammer_dict)

    # Print the header line to STDOUT
    print(header_line)
    # Sort and print the accepted hammer candidates
    for key in sorted(hammer_dict.keys()):
        print(hammer_dict[key])

    # Print statistics to STDERR
    accepted_count = len(hammer_dict)
    print("", file=sys.stderr)
    print(f"Candidates read: {candidates_read}", file=sys.stderr)
    print(f"Candidates eliminated: {eliminated_count}", file=sys.stderr)
    print(f"Hammers accepted: {accepted_count}", file=sys.stderr)


if __name__ == "__main__":
    main()
