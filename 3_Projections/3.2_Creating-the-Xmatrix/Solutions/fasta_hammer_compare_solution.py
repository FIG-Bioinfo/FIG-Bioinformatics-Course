#########################################################
#...Prompt used to generate code and pseudocode...
"""
Please write a program named `hammer_compare.py` that will:

* Accept a mandatory TSV "hammers" filename argument,
short name `-H`, long name `--hammers`.

* Accept a mandatory TSV genome-names filename argument,
short name `-G`, long name `--genome-names`.

* Skip the header-line of the hammer-file and then read
the first and second columns as a `hammer` and `feature_id`,
respectively. A `feature_id` has the format 'fig|x.y.peg.z',
where 'x', 'y', and 'z' are integers, and 'fig|' and '.peg.'
are literal substrings. The portion 'x.y' is the `genome_id`
for the 'feature_id'; extract the `genome_id` using a regex,
and build a dictionary mapping each hammer to its genome_id.

* Skip the header-line of the genome-names file and then read
the first and second columns into a dictionary as a `genome_id`
and `genome_name`, respectively.

* Determine the Kmer-length `K` of the hammers from the hammers dictionary.
(NOTE: all the hammers in the file will have the same length.)

* Use BioPython to read the sequences of the genome from `STDIN`.

* For each sequence, extract all possible Kmers, and if a Kmer is a hammer,
increment the score for its associated `genome_id`; then repeat this operation on the reverse-complement of that sequence, since a gene can face in either direction.

* Print to STDOUT a TSV file of the genome_ids found
and their associated genome_name and score sorted by decreasing score.
Please handle missing genome-names gracefully;
if a genome_id does not have an associated genome-name,
display the genome_name as 'Unknown sp.' in the output TSV file,
and send a warning to STDERR that the name of genome_id was not in
the genome-names file.
"""

#########################################################
#...Pseudocode generated by Grimoire...
"""
function parse_arguments()
    create argument parser
    add required argument "-H" / "--hammers" for hammers TSV file path
    add required argument "-G" / "--genome-names" for genome names TSV file path
    return parsed arguments

function load_hammers(hammer_file)
    create empty dictionary `hammer_dict`
    open `hammer_file` for reading
    skip the first line (header)
    for each line in the file:
        split line by tab into `parts`
        if `parts` has fewer than 2 elements, continue
        assign `parts[0]` to `hammer`
        assign `parts[1]` to `feature_id`
        extract `genome_id` from `feature_id` using regex "fig\|(\d+\.\d+)\.peg\.\d+"
        if a match is found:
            set `genome_id` in `hammer_dict` with key `hammer`
    return `hammer_dict`

function load_genome_names(genome_names_file)
    create empty dictionary `genome_names`
    open `genome_names_file` for reading
    skip the first line (header)
    for each line in the file:
        split line by tab into `parts`
        if `parts` has fewer than 2 elements, continue
        set `genome_id` to `parts[0]` and `genome_name` to `parts[1]`
        add `genome_id` with `genome_name` to `genome_names` dictionary
    return `genome_names`

function get_kmer_length(hammer_dict)
    return length of any `hammer` in `hammer_dict`

function process_sequences(hammer_dict, k, genome_names)
    create a dictionary `scores` with default value 0
    for each `record` in sequences from STDIN (fasta format):
        convert `record.seq` to string `sequence`
        for each position `i` in `sequence` from 0 to `len(sequence) - k`:
            set `kmer` to substring of `sequence` from `i` to `i + k`
            set `rev_kmer` to reverse complement of `kmer`
            if `kmer` is in `hammer_dict`:
                get `genome_id` from `hammer_dict` using `kmer`
                increment `scores[genome_id]`
            if `rev_kmer` is in `hammer_dict`:
                get `genome_id` from `hammer_dict` using `rev_kmer`
                increment `scores[genome_id]`
    return `scores`

function main()
    set `args` to result of `parse_arguments()`

    set `hammer_dict` to result of `load_hammers(args.hammers)`
    set `genome_names` to result of `load_genome_names(args.genome_names)`
    set `k` to result of `get_kmer_length(hammer_dict)`

    set `scores` to result of `process_sequences(hammer_dict, k, genome_names)`

    create empty list `results`
    for each `genome_id` and `score` in `scores` sorted by `score` in descending order:
        set `genome_name` to `genome_names[genome_id]` if it exists, else "Unknown sp."
        if `genome_name` is "Unknown sp.":
            print warning to STDERR: "genome_id not found in genome names file"
        append `(genome_id, genome_name, score)` to `results`
    
    print "genome_id\tgenome_name\tscore" to STDOUT
    for each `genome_id`, `genome_name`, and `score` in `results`:
        print `genome_id`, `genome_name`, and `score` separated by tabs to STDOUT

call `main()` to execute the program
"""

#########################################################
#...Code generated by Grimoire...
import argparse
import sys
import re
from Bio import SeqIO
from Bio.Seq import Seq
from collections import defaultdict

def parse_arguments():
    parser = argparse.ArgumentParser(description="Compare hammer Kmers with genome sequences")
    parser.add_argument("-H", "--hammers", required=True, help="Path to hammers TSV file")
    parser.add_argument("-G", "--genome-names", required=True, help="Path to genome names TSV file")
    parser.add_argument("-F", "--fasta", required=True, help="Path to FASTA file")
    return parser.parse_args()

def load_hammers(hammer_file):
    hammer_dict = {}
    with open(hammer_file, 'r') as f:
        next(f)  # Skip header
        for line in f:
            parts = line.strip().split('\t')
            if len(parts) < 2:
                continue
            hammer, feature_id = parts[0], parts[1]
            match = re.match(r'fig\|(\d+\.\d+)\.peg\.\d+', feature_id)
            if match:
                genome_id = match.group(1)
                hammer_dict[hammer] = genome_id
    return hammer_dict

def load_genome_names(genome_names_file):
    genome_names = {}
    with open(genome_names_file, 'r') as f:
        next(f)  # Skip header
        for line in f:
            parts = line.strip().split('\t')
            if len(parts) < 2:
                continue
            genome_id, genome_name = parts[0], parts[1]
            genome_names[genome_id] = genome_name
    return genome_names

def get_kmer_length(hammer_dict):
    # Assumes all hammers have the same length
    return len(next(iter(hammer_dict.keys())))

def process_sequences(hammer_dict, k, genome_names, fasta_file):
    scores = defaultdict(int)
    
    for record in SeqIO.parse(fasta_file, "fasta"):
        sequence = str(record.seq)
        
        for i in range(len(sequence) - k + 1):
            kmer = sequence[i:i + k]
            rev_kmer = str(Seq(kmer).reverse_complement())
            
            if kmer in hammer_dict:
                genome_id = hammer_dict[kmer]
                scores[genome_id] += 1
            if rev_kmer in hammer_dict:
                genome_id = hammer_dict[rev_kmer]
                scores[genome_id] += 1
                
    return scores

def main():
    args = parse_arguments()

    hammer_dict = load_hammers(args.hammers)
    genome_names = load_genome_names(args.genome_names)
    k = get_kmer_length(hammer_dict)

    scores = process_sequences(hammer_dict, k, genome_names, args.fasta)

    results = []
    for genome_id, score in sorted(scores.items(), key=lambda x: x[1], reverse=True):
        genome_name = genome_names.get(genome_id, "Unknown sp.")
        if genome_name == "Unknown sp.":
            print(f"Warning: {genome_id} not found in genome names file.", file=sys.stderr)
        results.append((genome_id, genome_name, score))
    
    # Print the results in TSV format
    print("genome_id\tgenome_name\tscore")
    for genome_id, genome_name, score in results:
        print(f"{genome_id}\t{genome_name}\t{score}")

if __name__ == "__main__":
    main()









