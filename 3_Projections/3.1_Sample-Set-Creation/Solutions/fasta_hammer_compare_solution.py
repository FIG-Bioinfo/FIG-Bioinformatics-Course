#########################################################
#...Prompt used to generate code and pseudocode...
"""
Please write a program named `hammer_compare.py` that will:

* Accept a mandatory TSV "hammers" filename argument,
short name `-H`, long name `--hammers`.

* Accept a mandatory TSV genome-names filename argument,
short name `-G`, long name `--genome-names`.

* Skip the header-line of the hammer-file and then read
the first and second columns as a `hammer` and `feature_id`,
respectively. A `feature_id` has the format 'fig|x.y.peg.z',
where 'x', 'y', and 'z' are integers, and 'fig|' and '.peg.'
are literal substrings. The portion 'x.y' is the `genome_id`
for the 'feature_id'; extract the `genome_id` using a regex,
and build a dictionary mapping each hammer to its genome_id.

* Skip the header-line of the genome-names file and then read
the first and second columns into a dictionary as a `genome_id`
and `genome_name`, respectively.

* Determine the Kmer-length `K` of the hammers from the hammers dictionary.
(NOTE: all the hammers in the file will have the same length.)

* Use BioPython to read the sequences of the genome from `STDIN`.

* For each sequence, extract all possible Kmers, and if a Kmer is a hammer,
increment the score for its associated `genome_id`; then repeat this operation on the reverse-complement of that sequence, since a gene can face in either direction.

* Print to STDOUT a TSV file of the genome_ids found
and their associated genome_name and score sorted by decreasing score.
Please handle missing genome-names gracefully;
if a genome_id does not have an associated genome-name,
display the genome_name as 'Unknown sp.' in the output TSV file,
and send a warning to STDERR that the name of genome_id was not in
the genome-names file.
"""

#########################################################
#...Pseudocode generated by Grimoire...
"""
function parse_arguments()
    create argument parser
    add required argument "-H" / "--hammers" for hammers TSV file path
    add required argument "-G" / "--genome-names" for genome names TSV file path
    return parsed arguments

function load_hammers(hammer_file)
    create empty dictionary `hammer_dict`
    open `hammer_file` for reading
    skip the first line (header)
    for each line in the file:
        split line by tab into `parts`
        if `parts` has fewer than 2 elements, continue
        assign `parts[0]` to `hammer`
        assign `parts[1]` to `feature_id`
        extract `genome_id` from `feature_id` using regex "fig\|(\d+\.\d+)\.peg\.\d+"
        if a match is found:
            set `genome_id` in `hammer_dict` with key `hammer`
    return `hammer_dict`

function load_genome_names(genome_names_file)
    create empty dictionary `genome_names`
    open `genome_names_file` for reading
    skip the first line (header)
    for each line in the file:
        split line by tab into `parts`
        if `parts` has fewer than 2 elements, continue
        set `genome_id` to `parts[0]` and `genome_name` to `parts[1]`
        add `genome_id` with `genome_name` to `genome_names` dictionary
    return `genome_names`

function get_kmer_length(hammer_dict)
    return length of any `hammer` in `hammer_dict`

function process_sequences(hammer_dict, k, genome_names)
    create a dictionary `scores` with default value 0
    for each `record` in sequences from STDIN (fasta format):
        convert `record.seq` to string `sequence`
        for each position `i` in `sequence` from 0 to `len(sequence) - k`:
            set `kmer` to substring of `sequence` from `i` to `i + k`
            set `rev_kmer` to reverse complement of `kmer`
            if `kmer` is in `hammer_dict`:
                get `genome_id` from `hammer_dict` using `kmer`
                increment `scores[genome_id]`
            if `rev_kmer` is in `hammer_dict`:
                get `genome_id` from `hammer_dict` using `rev_kmer`
                increment `scores[genome_id]`
    return `scores`

function main()
    set `args` to result of `parse_arguments()`

    set `hammer_dict` to result of `load_hammers(args.hammers)`
    set `genome_names` to result of `load_genome_names(args.genome_names)`
    set `k` to result of `get_kmer_length(hammer_dict)`

    set `scores` to result of `process_sequences(hammer_dict, k, genome_names)`

    create empty list `results`
    for each `genome_id` and `score` in `scores` sorted by `score` in descending order:
        set `genome_name` to `genome_names[genome_id]` if it exists, else "Unknown sp."
        if `genome_name` is "Unknown sp.":
            print warning to STDERR: "genome_id not found in genome names file"
        append `(genome_id, genome_name, score)` to `results`
    
    print "genome_id\tgenome_name\tscore" to STDOUT
    for each `genome_id`, `genome_name`, and `score` in `results`:
        print `genome_id`, `genome_name`, and `score` separated by tabs to STDOUT

call `main()` to execute the program
"""

#########################################################
#...Code generated by Grimoire...
import argparse
import sys
import re
from Bio import SeqIO
from Bio.Seq import Seq
from collections import defaultdict

def parse_arguments():
    parser = argparse.ArgumentParser(description="Compare hammer Kmers with genome sequences")
    parser.add_argument("-H", "--hammers", required=True, help="Path to hammers TSV file EX: Data/hammer_set.tsv")
    parser.add_argument("-G", "--genome-names", required=True, help="Path to genome names TSV file EX: Data/myrep50.genomes.tbl")
    parser.add_argument("-F", "--fasta", required=True, help="Path to FASTA file EX: Data/Controls/Control Sample A.fasta")
    return parser.parse_args()

def load_hammers(hammer_file):
    hammer_dict = {}
    with open(hammer_file, 'r') as f:
        next(f)  # Skip header
        counter = 0
        for line in f:
            parts = line.strip().split('\t')
            hammer, feature_id = parts[0], parts[1]
            match = re.match(r'fig\|(\d+\.\d+)\.peg\.\d+', feature_id)
            if match:
                genome_id = match.group(1)
                hammer_dict[hammer] = genome_id
            counter += 1
            if counter % 500000 == 0:
                print(f"Loaded {counter} hammers")
    return hammer_dict

def load_genome_names(genome_names_file):
    genome_names = {}
    with open(genome_names_file, 'r') as f:
        next(f)  # Skip header
        for line in f:
            parts = line.strip().split('\t')
            if len(parts) < 2:
                continue
            genome_id, genome_name = parts[0], parts[1]
            genome_names[genome_id] = genome_name
    return genome_names

def get_kmer_length(hammer_dict):
    # Assumes all hammers have the same length
    return len(next(iter(hammer_dict.keys())))

def process_sequences(hammer_dict, k, genome_names, fasta_file):
    scores = defaultdict(int)
    counter = 0
    for record in SeqIO.parse(fasta_file, "fasta"):
        sequence = str(record.seq)
        counter += 1
        for i in range(len(sequence) - k + 1):
            kmer = sequence[i:i + k].lower()
            rev_kmer = str(Seq(kmer).reverse_complement()).lower()
            if kmer in hammer_dict:
                genome_id = hammer_dict[kmer]
                scores[genome_id] += 1
            if rev_kmer in hammer_dict:
                genome_id = hammer_dict[rev_kmer]
                scores[genome_id] += 1

        if counter % 10000 == 0:
            print(f"Processed {counter} sequences against the hammer set.")
    return scores

def main():
    args = parse_arguments()

    hammer_dict = load_hammers(args.hammers)
    print("Hammers have been loaded")
    genome_names = load_genome_names(args.genome_names)
    print("Genome names have been loaded")
    k = get_kmer_length(hammer_dict)
    print("Kmer length has been calculated")

    scores = process_sequences(hammer_dict, k, genome_names, args.fasta)
    print(scores)
    print("Sequences have been processed")

    results = []
    for genome_id, score in sorted(scores.items(), key=lambda x: x[1], reverse=True):
        genome_name = genome_names.get(genome_id, "Unknown sp.")
        if genome_name == "Unknown sp.":
            print(f"Warning: {genome_id} not found in genome names file.", file=sys.stderr)
        results.append((genome_id, genome_name, score))
    
    # Print the results in TSV format
    # Get the base filename without extension and path
    sample_name = args.fasta.split("/")[-1].split(".")[0]
    output_file = f"Data/{sample_name}_hammer_report.tsv"
    
    # Write results to file
    print(f"Writing results to {output_file}")
    with open(output_file, 'w') as f:
        f.write("genome_id\tgenome_name\tscore\n")
        for genome_id, genome_name, score in results:
            f.write(f"{genome_id}\t{genome_name}\t{score}\n")

if __name__ == "__main__":
    main()









