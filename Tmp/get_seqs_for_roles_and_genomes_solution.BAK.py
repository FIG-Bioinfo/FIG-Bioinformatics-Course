########################################################################
#...Prompt that generated this program:
"""
Please write a python program named 'get_seqs_for_roles_and_genomes.py' that:

* Accepts the following three mandatory named arguments:
  - Type-flag, short name '-T', long name '--type',
    allowed values 'dna' or 'protein'.
    
  - Filename of a tab-separated-value list containing genome-IDs
    short name '-G', long name '--genome-list'.

  - Filename of a tab-separated-value list of roles,
    short name '-R', long-name '--role-list'.

* Reads the role-name file, skips the header-line,
and loads the remainder of the second column into a list.

* Foreach role in the role-list, print a progress-message to STDERR,
and then execute the follwing two commands, piping the output of 'cmd1'
to the input of 'cmd2', trapping any errors thrown by either command,
and printing the output of 'cmd2' to STDOUT;
note that the role can contain whitespace, and so this argument must be quoted:

   cmd1 = f"p3-get-genome-features --selective --input {genomes_filename} --col genome_id --eq product,'{role}' --attr patric_id"

   cmd2 = f"p3-get-feature-sequence --col feature.patric_id --{type}"

If either command fails, print the trapped error-message to STDERR, and then exit.
"""

########################################################################
#...Pseudocode for this program:
"""
DEFINE FUNCTION main():
    CREATE parser WITH argparse.ArgumentParser(description="Process genome features and sequences.")
    ADD ARGUMENT '-T' OR '--type' TO parser AS REQUIRED CHOICE ['dna', 'protein']
    ADD ARGUMENT '-G' OR '--genome-list' TO parser AS REQUIRED STRING
    ADD ARGUMENT '-R' OR '--role-list' TO parser AS REQUIRED STRING

    PARSE arguments INTO args

    SET type_flag TO args.type
    SET genome_file TO args.genome_list
    SET role_file TO args.role_list

    TRY:
        OPEN role_file AS role_f
        READ ALL LINES FROM role_f, SKIP THE FIRST LINE
        EXTRACT SECOND COLUMN FROM EACH LINE INTO roles LIST
    EXCEPT ANY ERROR AS e:
        PRINT "Error reading role list file: e" TO STDERR
        EXIT PROGRAM

    FOR EACH role IN roles:
        PRINT "Processing role: role" TO STDERR

        TRY:
            SET cmd1 TO [
                "p3-get-genome-features", 
                "--selective", 
                "--input", genome_file, 
                "--col", "genome_id", 
                "--eq", f"product,'role'", 
                "--attr", "patric_id"
            ]
            
            SET cmd2 TO [
                "p3-get-feature-sequence", 
                "--col", "feature.patric_id", 
                f"--type_flag"
            ]

            LAUNCH cmd1 AS process1 WITH stdout PIPE
            PIPE stdout OF process1 TO stdin OF cmd2 AS process2

            CLOSE process1.stdout TO ALLOW SIGPIPE SIGNALS
            CAPTURE stdout AND stderr FROM process2

            IF process1 RETURN CODE IS NOT SUCCESSFUL:
                RAISE ERROR WITH MESSAGE FROM process1.stderr

            IF process2 RETURN CODE IS NOT SUCCESSFUL:
                RAISE ERROR WITH MESSAGE stderr

            PRINT stdout FROM process2 TO STDOUT

        EXCEPT ANY ERROR AS e:
            PRINT "Error processing role: role - e" TO STDERR
            EXIT PROGRAM

END FUNCTION

CALL main()
"""

########################################################################
#...Code generated by Grimoire:
import argparse
import subprocess
import sys

def main():
    # Set up argument parsing
    parser = argparse.ArgumentParser(description="Process genome features and sequences.")
    parser.add_argument('-T', '--type', choices=['dna', 'protein'], required=True, help="Type of sequence (dna or protein).")
    parser.add_argument('-G', '--genome-list', required=True, help="File containing a list of genome IDs.")
    parser.add_argument('-R', '--role-list', required=True, help="File containing a list of roles.")

    args = parser.parse_args()

    type_flag = args.type
    genome_file = args.genome_list
    role_file = args.role_list

    # Load roles from role list file
    try:
        with open(role_file, 'r') as role_f:
            roles = [line.strip().split('\t')[1] for line in role_f.readlines()[1:]]  # Skip the header
    except Exception as e:
        sys.stderr.write(f"Error reading role list file: {e}\n")
        sys.exit(1)

    # Process each role
    for role in roles:
        sys.stderr.write(f"Processing role: {role}\n")
        try:
            # Command 1
            cmd1 = [
                "p3-get-genome-features", 
                "--selective", 
                "--input", genome_file, 
                "--col", "genome_id", 
                "--eq", f"product,{role}", 
                "--attr", "patric_id"
            ]
            # Command 2
            cmd2 = [
                "p3-get-feature-sequence", 
                "--col", "feature.patric_id", 
                f"--{type_flag}"
            ]

            # Run the commands with piping
            process1 = subprocess.Popen(cmd1, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            process2 = subprocess.Popen(cmd2, stdin=process1.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            process1.stdout.close()  # Allow process1 to receive a SIGPIPE if process2 exits
            stdout, stderr = process2.communicate()

            if process1.returncode not in (None, 0):
                raise RuntimeError(f"Command 1 failed with error: {process1.stderr.read()}")
            if process2.returncode not in (None, 0):
                raise RuntimeError(f"Command 2 failed with error: {stderr}")

            # Output the result of cmd2
            sys.stdout.write(stdout)

        except Exception as e:
            sys.stderr.write(f"Error processing role '{role}': {e}\n")
            sys.exit(1)

if __name__ == "__main__":
    main()
